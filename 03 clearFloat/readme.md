## 浮动元素引起的问题：
浮动元素脱离文档流，不占据空间。则会引起 
* 父元素的高度无法被撑开（demo1.html），影响父元素的同级元素
* 与浮动元素同级的非浮动元素会收到影响（demo2.html）：非浮动块级元素会和浮动元素有重叠部分、非浮动内联（行内）元素会紧随其后
* 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构(demo3.html)

### 浮动引起的问题归结起来就是——脱离文档流，对页面元素排列造成影响。
清除浮动就是为了 不影响文档流的正常排列
## 解决的办法 

 ## 解决办法可以分为两类：
 #### 1、利用clear<br>
 #### 2、触发父元素的BFC（块级格式上下文）
* 使用带clear属性的空元素<br>
  在浮动元素后使用一个空元素如` <div class="clear"></div> `，并在CSS中赋予` .clear{clear:both;} `属性即可清理浮动。亦可使用` <br class="clear" /> ` 或 ` <hr class="clear" /> `来进行清除。
<br>评价：兼容性强，但是浪费标签。
* 使用CSS的overflow属性+zoom<br>
  给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。
  在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。
<br>评价：触发父级元素，兼容性强，但是有的元素可能需要margin负值定位或者负值绝对定位，那么hidden之后会被裁掉了，有影响。
* 使用:after伪元素<br>
  类似第一种方式，在浮动元素的容器上加上::after，然后content设为看不见的空格或者.，然后赋予其clear属性来清除浮动。和第一种方式是异曲同工的。
<br>::after用来创建一个伪元素，做为已选中元素的最后一个子元素；不会影响其他样式。另外，为了兼容，可能需要容器上加上zoom:1.
* 给浮动元素的容器也添加上浮动<br>
  这样可以清除容器内部的浮动，但是会使整天浮动，影响布局。

* 给浮动元素的邻接元素添加clear属性<br>
  和第一种一样
  
  

[clear详解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear)  
  
    